<?php
/**
 * BcfApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BIMData API
 *
 * BIMData API is a tool to interact with your models stored on BIMDataâ€™s servers.     Through the API, you can manage your projects, the clouds, upload your IFC files and manage them through endpoints.
 *
 * The version of the OpenAPI document: v1 (v1)
 * Contact: support@bimdata.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * BcfApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BcfApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        "createComment" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createExtensionLabel" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createExtensionPriority" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createExtensionStage" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createExtensionStatus" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createExtensionType" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createFullTopic" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createTopic" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "createViewpoint" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "deleteComment" => ["application/json"],
        "deleteExtensionLabel" => ["application/json"],
        "deleteExtensionPriority" => ["application/json"],
        "deleteExtensionStage" => ["application/json"],
        "deleteExtensionStatus" => ["application/json"],
        "deleteExtensionType" => ["application/json"],
        "deleteTopic" => ["application/json"],
        "deleteViewpoint" => ["application/json"],
        "downloadBcfExport" => ["application/json"],
        "fullUpdateBcfProject" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "fullUpdateComment" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "fullUpdateFullTopic" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "fullUpdateTopic" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "fullUpdateViewpoint" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "getBcfProject" => ["application/json"],
        "getBcfProjects" => ["application/json"],
        "getColorings" => ["application/json"],
        "getComment" => ["application/json"],
        "getComments" => ["application/json"],
        "getDetailedExtensions" => ["application/json"],
        "getExtensions" => ["application/json"],
        "getFullTopic" => ["application/json"],
        "getFullTopics" => ["application/json"],
        "getSelections" => ["application/json"],
        "getSnapshot" => ["application/json"],
        "getTopic" => ["application/json"],
        "getTopicViewpoints" => ["application/json"],
        "getTopics" => ["application/json"],
        "getUser" => ["application/json"],
        "getViewpoint" => ["application/json"],
        "getViewpoints" => ["application/json"],
        "getVisibilities" => ["application/json"],
        "importBcf" => [
            "multipart/form-data",
            "application/x-www-form-urlencoded",
        ],
        "updateBcfProject" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateComment" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateExtensionLabel" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateExtensionPriority" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateExtensionStage" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateExtensionStatus" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateExtensionType" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateFullTopic" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateTopic" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
        "updateViewpoint" => [
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data",
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createComment
     *
     * Create a comment
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Comment
     */
    public function createComment(
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["createComment"][0]
    ) {
        list($response) = $this->createCommentWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createCommentWithHttpInfo
     *
     * Create a comment
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCommentWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["createComment"][0]
    ) {
        $request = $this->createCommentRequest(
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if ("\OpenAPI\Client\Model\Comment" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Comment" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Comment",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Comment";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Comment",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCommentAsync
     *
     * Create a comment
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCommentAsync(
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["createComment"][0]
    ) {
        return $this->createCommentAsyncWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createCommentAsyncWithHttpInfo
     *
     * Create a comment
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCommentAsyncWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["createComment"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Comment";
        $request = $this->createCommentRequest(
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createComment'
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCommentRequest(
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["createComment"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createComment'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling createComment'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization($comment_request)
                );
            } else {
                $httpBody = $comment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExtensionLabel
     *
     * Create a Label
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\LabelRequest $label_request label_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionLabel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Label
     */
    public function createExtensionLabel(
        $projects_pk,
        $label_request,
        string $contentType = self::contentTypes["createExtensionLabel"][0]
    ) {
        list($response) = $this->createExtensionLabelWithHttpInfo(
            $projects_pk,
            $label_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createExtensionLabelWithHttpInfo
     *
     * Create a Label
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\LabelRequest $label_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionLabel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExtensionLabelWithHttpInfo(
        $projects_pk,
        $label_request,
        string $contentType = self::contentTypes["createExtensionLabel"][0]
    ) {
        $request = $this->createExtensionLabelRequest(
            $projects_pk,
            $label_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if ("\OpenAPI\Client\Model\Label" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Label" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Label",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Label";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Label",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExtensionLabelAsync
     *
     * Create a Label
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\LabelRequest $label_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionLabelAsync(
        $projects_pk,
        $label_request,
        string $contentType = self::contentTypes["createExtensionLabel"][0]
    ) {
        return $this->createExtensionLabelAsyncWithHttpInfo(
            $projects_pk,
            $label_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createExtensionLabelAsyncWithHttpInfo
     *
     * Create a Label
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\LabelRequest $label_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionLabelAsyncWithHttpInfo(
        $projects_pk,
        $label_request,
        string $contentType = self::contentTypes["createExtensionLabel"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Label";
        $request = $this->createExtensionLabelRequest(
            $projects_pk,
            $label_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExtensionLabel'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\LabelRequest $label_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createExtensionLabelRequest(
        $projects_pk,
        $label_request,
        string $contentType = self::contentTypes["createExtensionLabel"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createExtensionLabel'
            );
        }

        // verify the required parameter 'label_request' is set
        if (
            $label_request === null ||
            (is_array($label_request) && count($label_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $label_request when calling createExtensionLabel'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/label";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($label_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization($label_request)
                );
            } else {
                $httpBody = $label_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExtensionPriority
     *
     * Create a Priority
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PriorityRequest $priority_request priority_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionPriority'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Priority
     */
    public function createExtensionPriority(
        $projects_pk,
        $priority_request,
        string $contentType = self::contentTypes["createExtensionPriority"][0]
    ) {
        list($response) = $this->createExtensionPriorityWithHttpInfo(
            $projects_pk,
            $priority_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createExtensionPriorityWithHttpInfo
     *
     * Create a Priority
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PriorityRequest $priority_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionPriority'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Priority, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExtensionPriorityWithHttpInfo(
        $projects_pk,
        $priority_request,
        string $contentType = self::contentTypes["createExtensionPriority"][0]
    ) {
        $request = $this->createExtensionPriorityRequest(
            $projects_pk,
            $priority_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if ("\OpenAPI\Client\Model\Priority" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Priority" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Priority",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Priority";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Priority",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExtensionPriorityAsync
     *
     * Create a Priority
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PriorityRequest $priority_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionPriorityAsync(
        $projects_pk,
        $priority_request,
        string $contentType = self::contentTypes["createExtensionPriority"][0]
    ) {
        return $this->createExtensionPriorityAsyncWithHttpInfo(
            $projects_pk,
            $priority_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createExtensionPriorityAsyncWithHttpInfo
     *
     * Create a Priority
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PriorityRequest $priority_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionPriorityAsyncWithHttpInfo(
        $projects_pk,
        $priority_request,
        string $contentType = self::contentTypes["createExtensionPriority"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Priority";
        $request = $this->createExtensionPriorityRequest(
            $projects_pk,
            $priority_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExtensionPriority'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PriorityRequest $priority_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createExtensionPriorityRequest(
        $projects_pk,
        $priority_request,
        string $contentType = self::contentTypes["createExtensionPriority"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createExtensionPriority'
            );
        }

        // verify the required parameter 'priority_request' is set
        if (
            $priority_request === null ||
            (is_array($priority_request) && count($priority_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $priority_request when calling createExtensionPriority'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/priority";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($priority_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $priority_request
                    )
                );
            } else {
                $httpBody = $priority_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExtensionStage
     *
     * Create a Stage
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\StageRequest $stage_request stage_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Stage
     */
    public function createExtensionStage(
        $projects_pk,
        $stage_request,
        string $contentType = self::contentTypes["createExtensionStage"][0]
    ) {
        list($response) = $this->createExtensionStageWithHttpInfo(
            $projects_pk,
            $stage_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createExtensionStageWithHttpInfo
     *
     * Create a Stage
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\StageRequest $stage_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Stage, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExtensionStageWithHttpInfo(
        $projects_pk,
        $stage_request,
        string $contentType = self::contentTypes["createExtensionStage"][0]
    ) {
        $request = $this->createExtensionStageRequest(
            $projects_pk,
            $stage_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if ("\OpenAPI\Client\Model\Stage" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Stage" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Stage",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Stage";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Stage",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExtensionStageAsync
     *
     * Create a Stage
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\StageRequest $stage_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionStageAsync(
        $projects_pk,
        $stage_request,
        string $contentType = self::contentTypes["createExtensionStage"][0]
    ) {
        return $this->createExtensionStageAsyncWithHttpInfo(
            $projects_pk,
            $stage_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createExtensionStageAsyncWithHttpInfo
     *
     * Create a Stage
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\StageRequest $stage_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionStageAsyncWithHttpInfo(
        $projects_pk,
        $stage_request,
        string $contentType = self::contentTypes["createExtensionStage"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Stage";
        $request = $this->createExtensionStageRequest(
            $projects_pk,
            $stage_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExtensionStage'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\StageRequest $stage_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createExtensionStageRequest(
        $projects_pk,
        $stage_request,
        string $contentType = self::contentTypes["createExtensionStage"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createExtensionStage'
            );
        }

        // verify the required parameter 'stage_request' is set
        if (
            $stage_request === null ||
            (is_array($stage_request) && count($stage_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stage_request when calling createExtensionStage'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/stage";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($stage_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization($stage_request)
                );
            } else {
                $httpBody = $stage_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExtensionStatus
     *
     * Create a TopicStatus
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicStatusRequest $topic_status_request topic_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TopicStatus
     */
    public function createExtensionStatus(
        $projects_pk,
        $topic_status_request,
        string $contentType = self::contentTypes["createExtensionStatus"][0]
    ) {
        list($response) = $this->createExtensionStatusWithHttpInfo(
            $projects_pk,
            $topic_status_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createExtensionStatusWithHttpInfo
     *
     * Create a TopicStatus
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicStatusRequest $topic_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TopicStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExtensionStatusWithHttpInfo(
        $projects_pk,
        $topic_status_request,
        string $contentType = self::contentTypes["createExtensionStatus"][0]
    ) {
        $request = $this->createExtensionStatusRequest(
            $projects_pk,
            $topic_status_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if (
                        "\OpenAPI\Client\Model\TopicStatus" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\TopicStatus" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\TopicStatus",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\TopicStatus";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\TopicStatus",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExtensionStatusAsync
     *
     * Create a TopicStatus
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicStatusRequest $topic_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionStatusAsync(
        $projects_pk,
        $topic_status_request,
        string $contentType = self::contentTypes["createExtensionStatus"][0]
    ) {
        return $this->createExtensionStatusAsyncWithHttpInfo(
            $projects_pk,
            $topic_status_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createExtensionStatusAsyncWithHttpInfo
     *
     * Create a TopicStatus
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicStatusRequest $topic_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionStatusAsyncWithHttpInfo(
        $projects_pk,
        $topic_status_request,
        string $contentType = self::contentTypes["createExtensionStatus"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\TopicStatus";
        $request = $this->createExtensionStatusRequest(
            $projects_pk,
            $topic_status_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExtensionStatus'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicStatusRequest $topic_status_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createExtensionStatusRequest(
        $projects_pk,
        $topic_status_request,
        string $contentType = self::contentTypes["createExtensionStatus"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createExtensionStatus'
            );
        }

        // verify the required parameter 'topic_status_request' is set
        if (
            $topic_status_request === null ||
            (is_array($topic_status_request) &&
                count($topic_status_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topic_status_request when calling createExtensionStatus'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/status";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($topic_status_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $topic_status_request
                    )
                );
            } else {
                $httpBody = $topic_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createExtensionType
     *
     * Create a TopicType
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicTypeRequest $topic_type_request topic_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TopicType
     */
    public function createExtensionType(
        $projects_pk,
        $topic_type_request,
        string $contentType = self::contentTypes["createExtensionType"][0]
    ) {
        list($response) = $this->createExtensionTypeWithHttpInfo(
            $projects_pk,
            $topic_type_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createExtensionTypeWithHttpInfo
     *
     * Create a TopicType
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicTypeRequest $topic_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TopicType, HTTP status code, HTTP response headers (array of strings)
     */
    public function createExtensionTypeWithHttpInfo(
        $projects_pk,
        $topic_type_request,
        string $contentType = self::contentTypes["createExtensionType"][0]
    ) {
        $request = $this->createExtensionTypeRequest(
            $projects_pk,
            $topic_type_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if (
                        "\OpenAPI\Client\Model\TopicType" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\TopicType" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\TopicType",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\TopicType";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\TopicType",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createExtensionTypeAsync
     *
     * Create a TopicType
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicTypeRequest $topic_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionTypeAsync(
        $projects_pk,
        $topic_type_request,
        string $contentType = self::contentTypes["createExtensionType"][0]
    ) {
        return $this->createExtensionTypeAsyncWithHttpInfo(
            $projects_pk,
            $topic_type_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createExtensionTypeAsyncWithHttpInfo
     *
     * Create a TopicType
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicTypeRequest $topic_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createExtensionTypeAsyncWithHttpInfo(
        $projects_pk,
        $topic_type_request,
        string $contentType = self::contentTypes["createExtensionType"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\TopicType";
        $request = $this->createExtensionTypeRequest(
            $projects_pk,
            $topic_type_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createExtensionType'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicTypeRequest $topic_type_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createExtensionTypeRequest(
        $projects_pk,
        $topic_type_request,
        string $contentType = self::contentTypes["createExtensionType"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createExtensionType'
            );
        }

        // verify the required parameter 'topic_type_request' is set
        if (
            $topic_type_request === null ||
            (is_array($topic_type_request) && count($topic_type_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topic_type_request when calling createExtensionType'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/type";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($topic_type_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $topic_type_request
                    )
                );
            } else {
                $httpBody = $topic_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFullTopic
     *
     * Create a Topic with viewpoints and comments
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FullTopic
     */
    public function createFullTopic(
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["createFullTopic"][0]
    ) {
        list($response) = $this->createFullTopicWithHttpInfo(
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createFullTopicWithHttpInfo
     *
     * Create a Topic with viewpoints and comments
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FullTopic, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFullTopicWithHttpInfo(
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["createFullTopic"][0]
    ) {
        $request = $this->createFullTopicRequest(
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if (
                        "\OpenAPI\Client\Model\FullTopic" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\FullTopic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\FullTopic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\FullTopic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\FullTopic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFullTopicAsync
     *
     * Create a Topic with viewpoints and comments
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFullTopicAsync(
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["createFullTopic"][0]
    ) {
        return $this->createFullTopicAsyncWithHttpInfo(
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createFullTopicAsyncWithHttpInfo
     *
     * Create a Topic with viewpoints and comments
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFullTopicAsyncWithHttpInfo(
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["createFullTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\FullTopic";
        $request = $this->createFullTopicRequest(
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFullTopic'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFullTopicRequest(
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["createFullTopic"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createFullTopic'
            );
        }

        // verify the required parameter 'full_topic_request' is set
        if (
            $full_topic_request === null ||
            (is_array($full_topic_request) && count($full_topic_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $full_topic_request when calling createFullTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/full-topic";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($full_topic_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $full_topic_request
                    )
                );
            } else {
                $httpBody = $full_topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTopic
     *
     * Create a topic
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Topic
     */
    public function createTopic(
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["createTopic"][0]
    ) {
        list($response) = $this->createTopicWithHttpInfo(
            $projects_pk,
            $topic_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createTopicWithHttpInfo
     *
     * Create a topic
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Topic, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTopicWithHttpInfo(
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["createTopic"][0]
    ) {
        $request = $this->createTopicRequest(
            $projects_pk,
            $topic_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if ("\OpenAPI\Client\Model\Topic" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Topic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Topic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Topic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Topic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTopicAsync
     *
     * Create a topic
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTopicAsync(
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["createTopic"][0]
    ) {
        return $this->createTopicAsyncWithHttpInfo(
            $projects_pk,
            $topic_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createTopicAsyncWithHttpInfo
     *
     * Create a topic
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTopicAsyncWithHttpInfo(
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["createTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Topic";
        $request = $this->createTopicRequest(
            $projects_pk,
            $topic_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTopic'
     *
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTopicRequest(
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["createTopic"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createTopic'
            );
        }

        // verify the required parameter 'topic_request' is set
        if (
            $topic_request === null ||
            (is_array($topic_request) && count($topic_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topic_request when calling createTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/topics";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($topic_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization($topic_request)
                );
            } else {
                $httpBody = $topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createViewpoint
     *
     * Create a Viewpoint
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Viewpoint
     */
    public function createViewpoint(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["createViewpoint"][0]
    ) {
        list($response) = $this->createViewpointWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation createViewpointWithHttpInfo
     *
     * Create a Viewpoint
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Viewpoint, HTTP status code, HTTP response headers (array of strings)
     */
    public function createViewpointWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["createViewpoint"][0]
    ) {
        $request = $this->createViewpointRequest(
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 201:
                    if (
                        "\OpenAPI\Client\Model\Viewpoint" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Viewpoint" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Viewpoint",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Viewpoint";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Viewpoint",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createViewpointAsync
     *
     * Create a Viewpoint
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createViewpointAsync(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["createViewpoint"][0]
    ) {
        return $this->createViewpointAsyncWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation createViewpointAsyncWithHttpInfo
     *
     * Create a Viewpoint
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createViewpointAsyncWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["createViewpoint"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Viewpoint";
        $request = $this->createViewpointRequest(
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createViewpoint'
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createViewpointRequest(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["createViewpoint"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling createViewpoint'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling createViewpoint'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($viewpoint_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $viewpoint_request
                    )
                );
            } else {
                $httpBody = $viewpoint_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteComment
     *
     * Delete a comment
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteComment(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["deleteComment"][0]
    ) {
        $this->deleteCommentWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );
    }

    /**
     * Operation deleteCommentWithHttpInfo
     *
     * Delete a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCommentWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["deleteComment"][0]
    ) {
        $request = $this->deleteCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCommentAsync
     *
     * Delete a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["deleteComment"][0]
    ) {
        return $this->deleteCommentAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteCommentAsyncWithHttpInfo
     *
     * Delete a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["deleteComment"][0]
    ) {
        $returnType = "";
        $request = $this->deleteCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteComment'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCommentRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["deleteComment"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling deleteComment'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteComment'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling deleteComment'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteExtensionLabel
     *
     * Delete a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionLabel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteExtensionLabel(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionLabel"][0]
    ) {
        $this->deleteExtensionLabelWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        );
    }

    /**
     * Operation deleteExtensionLabelWithHttpInfo
     *
     * Delete a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionLabel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteExtensionLabelWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionLabel"][0]
    ) {
        $request = $this->deleteExtensionLabelRequest(
            $id,
            $projects_pk,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteExtensionLabelAsync
     *
     * Delete a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionLabelAsync(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionLabel"][0]
    ) {
        return $this->deleteExtensionLabelAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteExtensionLabelAsyncWithHttpInfo
     *
     * Delete a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionLabelAsyncWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionLabel"][0]
    ) {
        $returnType = "";
        $request = $this->deleteExtensionLabelRequest(
            $id,
            $projects_pk,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteExtensionLabel'
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteExtensionLabelRequest(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionLabel"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteExtensionLabel'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteExtensionLabel'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/label/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteExtensionPriority
     *
     * Delete a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionPriority'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteExtensionPriority(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionPriority"][0]
    ) {
        $this->deleteExtensionPriorityWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        );
    }

    /**
     * Operation deleteExtensionPriorityWithHttpInfo
     *
     * Delete a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionPriority'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteExtensionPriorityWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionPriority"][0]
    ) {
        $request = $this->deleteExtensionPriorityRequest(
            $id,
            $projects_pk,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteExtensionPriorityAsync
     *
     * Delete a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionPriorityAsync(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionPriority"][0]
    ) {
        return $this->deleteExtensionPriorityAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteExtensionPriorityAsyncWithHttpInfo
     *
     * Delete a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionPriorityAsyncWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionPriority"][0]
    ) {
        $returnType = "";
        $request = $this->deleteExtensionPriorityRequest(
            $id,
            $projects_pk,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteExtensionPriority'
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteExtensionPriorityRequest(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionPriority"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteExtensionPriority'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteExtensionPriority'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/extension/priority/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteExtensionStage
     *
     * Delete a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteExtensionStage(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStage"][0]
    ) {
        $this->deleteExtensionStageWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        );
    }

    /**
     * Operation deleteExtensionStageWithHttpInfo
     *
     * Delete a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteExtensionStageWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStage"][0]
    ) {
        $request = $this->deleteExtensionStageRequest(
            $id,
            $projects_pk,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteExtensionStageAsync
     *
     * Delete a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionStageAsync(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStage"][0]
    ) {
        return $this->deleteExtensionStageAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteExtensionStageAsyncWithHttpInfo
     *
     * Delete a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionStageAsyncWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStage"][0]
    ) {
        $returnType = "";
        $request = $this->deleteExtensionStageRequest(
            $id,
            $projects_pk,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteExtensionStage'
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteExtensionStageRequest(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStage"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteExtensionStage'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteExtensionStage'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/stage/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteExtensionStatus
     *
     * Delete a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteExtensionStatus(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStatus"][0]
    ) {
        $this->deleteExtensionStatusWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        );
    }

    /**
     * Operation deleteExtensionStatusWithHttpInfo
     *
     * Delete a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteExtensionStatusWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStatus"][0]
    ) {
        $request = $this->deleteExtensionStatusRequest(
            $id,
            $projects_pk,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteExtensionStatusAsync
     *
     * Delete a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionStatusAsync(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStatus"][0]
    ) {
        return $this->deleteExtensionStatusAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteExtensionStatusAsyncWithHttpInfo
     *
     * Delete a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionStatusAsyncWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStatus"][0]
    ) {
        $returnType = "";
        $request = $this->deleteExtensionStatusRequest(
            $id,
            $projects_pk,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteExtensionStatus'
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteExtensionStatusRequest(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionStatus"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteExtensionStatus'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteExtensionStatus'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/status/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteExtensionType
     *
     * Delete a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteExtensionType(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionType"][0]
    ) {
        $this->deleteExtensionTypeWithHttpInfo($id, $projects_pk, $contentType);
    }

    /**
     * Operation deleteExtensionTypeWithHttpInfo
     *
     * Delete a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteExtensionTypeWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionType"][0]
    ) {
        $request = $this->deleteExtensionTypeRequest(
            $id,
            $projects_pk,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteExtensionTypeAsync
     *
     * Delete a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionTypeAsync(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionType"][0]
    ) {
        return $this->deleteExtensionTypeAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteExtensionTypeAsyncWithHttpInfo
     *
     * Delete a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteExtensionTypeAsyncWithHttpInfo(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionType"][0]
    ) {
        $returnType = "";
        $request = $this->deleteExtensionTypeRequest(
            $id,
            $projects_pk,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteExtensionType'
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteExtensionTypeRequest(
        $id,
        $projects_pk,
        string $contentType = self::contentTypes["deleteExtensionType"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteExtensionType'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteExtensionType'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/type/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTopic
     *
     * Delete a topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTopic(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["deleteTopic"][0]
    ) {
        $this->deleteTopicWithHttpInfo($guid, $projects_pk, $contentType);
    }

    /**
     * Operation deleteTopicWithHttpInfo
     *
     * Delete a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTopicWithHttpInfo(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["deleteTopic"][0]
    ) {
        $request = $this->deleteTopicRequest($guid, $projects_pk, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTopicAsync
     *
     * Delete a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTopicAsync(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["deleteTopic"][0]
    ) {
        return $this->deleteTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteTopicAsyncWithHttpInfo
     *
     * Delete a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["deleteTopic"][0]
    ) {
        $returnType = "";
        $request = $this->deleteTopicRequest($guid, $projects_pk, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTopicRequest(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["deleteTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling deleteTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/topics/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteViewpoint
     *
     * Delete a Viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteViewpoint(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["deleteViewpoint"][0]
    ) {
        $this->deleteViewpointWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );
    }

    /**
     * Operation deleteViewpointWithHttpInfo
     *
     * Delete a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteViewpointWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["deleteViewpoint"][0]
    ) {
        $request = $this->deleteViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteViewpointAsync
     *
     * Delete a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteViewpointAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["deleteViewpoint"][0]
    ) {
        return $this->deleteViewpointAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation deleteViewpointAsyncWithHttpInfo
     *
     * Delete a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteViewpointAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["deleteViewpoint"][0]
    ) {
        $returnType = "";
        $request = $this->deleteViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteViewpoint'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteViewpointRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["deleteViewpoint"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling deleteViewpoint'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling deleteViewpoint'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling deleteViewpoint'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "DELETE",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadBcfExport
     *
     * Export project&#39;s topics in bcf-xml format
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $format topic format to export, comma separated. Default &#x3D; standard (optional)
     * @param  string $topics topic guids to export, comma separated. Default &#x3D; all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadBcfExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadBcfExport(
        $id,
        $format = null,
        $topics = null,
        string $contentType = self::contentTypes["downloadBcfExport"][0]
    ) {
        list($response) = $this->downloadBcfExportWithHttpInfo(
            $id,
            $format,
            $topics,
            $contentType
        );
        return $response;
    }

    /**
     * Operation downloadBcfExportWithHttpInfo
     *
     * Export project&#39;s topics in bcf-xml format
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $format topic format to export, comma separated. Default &#x3D; standard (optional)
     * @param  string $topics topic guids to export, comma separated. Default &#x3D; all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadBcfExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadBcfExportWithHttpInfo(
        $id,
        $format = null,
        $topics = null,
        string $contentType = self::contentTypes["downloadBcfExport"][0]
    ) {
        $request = $this->downloadBcfExportRequest(
            $id,
            $format,
            $topics,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\SplFileObject" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\SplFileObject" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\SplFileObject",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\SplFileObject";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\SplFileObject",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadBcfExportAsync
     *
     * Export project&#39;s topics in bcf-xml format
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $format topic format to export, comma separated. Default &#x3D; standard (optional)
     * @param  string $topics topic guids to export, comma separated. Default &#x3D; all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadBcfExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadBcfExportAsync(
        $id,
        $format = null,
        $topics = null,
        string $contentType = self::contentTypes["downloadBcfExport"][0]
    ) {
        return $this->downloadBcfExportAsyncWithHttpInfo(
            $id,
            $format,
            $topics,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation downloadBcfExportAsyncWithHttpInfo
     *
     * Export project&#39;s topics in bcf-xml format
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $format topic format to export, comma separated. Default &#x3D; standard (optional)
     * @param  string $topics topic guids to export, comma separated. Default &#x3D; all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadBcfExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadBcfExportAsyncWithHttpInfo(
        $id,
        $format = null,
        $topics = null,
        string $contentType = self::contentTypes["downloadBcfExport"][0]
    ) {
        $returnType = "\SplFileObject";
        $request = $this->downloadBcfExportRequest(
            $id,
            $format,
            $topics,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadBcfExport'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $format topic format to export, comma separated. Default &#x3D; standard (optional)
     * @param  string $topics topic guids to export, comma separated. Default &#x3D; all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadBcfExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadBcfExportRequest(
        $id,
        $format = null,
        $topics = null,
        string $contentType = self::contentTypes["downloadBcfExport"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling downloadBcfExport'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}/export";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $format,
                "format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );
        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $topics,
                "topics", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fullUpdateBcfProject
     *
     * Update all fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\BcfProjectRequest $bcf_project_request bcf_project_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateBcfProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BcfProject
     */
    public function fullUpdateBcfProject(
        $id,
        $bcf_project_request,
        string $contentType = self::contentTypes["fullUpdateBcfProject"][0]
    ) {
        list($response) = $this->fullUpdateBcfProjectWithHttpInfo(
            $id,
            $bcf_project_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation fullUpdateBcfProjectWithHttpInfo
     *
     * Update all fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\BcfProjectRequest $bcf_project_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateBcfProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BcfProject, HTTP status code, HTTP response headers (array of strings)
     */
    public function fullUpdateBcfProjectWithHttpInfo(
        $id,
        $bcf_project_request,
        string $contentType = self::contentTypes["fullUpdateBcfProject"][0]
    ) {
        $request = $this->fullUpdateBcfProjectRequest(
            $id,
            $bcf_project_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\BcfProject" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\BcfProject" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\BcfProject",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\BcfProject";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\BcfProject",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fullUpdateBcfProjectAsync
     *
     * Update all fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\BcfProjectRequest $bcf_project_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateBcfProjectAsync(
        $id,
        $bcf_project_request,
        string $contentType = self::contentTypes["fullUpdateBcfProject"][0]
    ) {
        return $this->fullUpdateBcfProjectAsyncWithHttpInfo(
            $id,
            $bcf_project_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation fullUpdateBcfProjectAsyncWithHttpInfo
     *
     * Update all fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\BcfProjectRequest $bcf_project_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateBcfProjectAsyncWithHttpInfo(
        $id,
        $bcf_project_request,
        string $contentType = self::contentTypes["fullUpdateBcfProject"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\BcfProject";
        $request = $this->fullUpdateBcfProjectRequest(
            $id,
            $bcf_project_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fullUpdateBcfProject'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\BcfProjectRequest $bcf_project_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fullUpdateBcfProjectRequest(
        $id,
        $bcf_project_request,
        string $contentType = self::contentTypes["fullUpdateBcfProject"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling fullUpdateBcfProject'
            );
        }

        // verify the required parameter 'bcf_project_request' is set
        if (
            $bcf_project_request === null ||
            (is_array($bcf_project_request) &&
                count($bcf_project_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bcf_project_request when calling fullUpdateBcfProject'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bcf_project_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $bcf_project_request
                    )
                );
            } else {
                $httpBody = $bcf_project_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PUT",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fullUpdateComment
     *
     * Update all fields of a comment
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Comment
     */
    public function fullUpdateComment(
        $guid,
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["fullUpdateComment"][0]
    ) {
        list($response) = $this->fullUpdateCommentWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation fullUpdateCommentWithHttpInfo
     *
     * Update all fields of a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function fullUpdateCommentWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["fullUpdateComment"][0]
    ) {
        $request = $this->fullUpdateCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Comment" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Comment" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Comment",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Comment";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Comment",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fullUpdateCommentAsync
     *
     * Update all fields of a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateCommentAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["fullUpdateComment"][0]
    ) {
        return $this->fullUpdateCommentAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation fullUpdateCommentAsyncWithHttpInfo
     *
     * Update all fields of a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateCommentAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["fullUpdateComment"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Comment";
        $request = $this->fullUpdateCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $comment_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fullUpdateComment'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\CommentRequest $comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fullUpdateCommentRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        $comment_request = null,
        string $contentType = self::contentTypes["fullUpdateComment"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling fullUpdateComment'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling fullUpdateComment'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling fullUpdateComment'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($comment_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization($comment_request)
                );
            } else {
                $httpBody = $comment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PUT",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fullUpdateFullTopic
     *
     * Update all fields of a topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FullTopic
     */
    public function fullUpdateFullTopic(
        $guid,
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["fullUpdateFullTopic"][0]
    ) {
        list($response) = $this->fullUpdateFullTopicWithHttpInfo(
            $guid,
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        );
        return $response;
    }

    /**
     * Operation fullUpdateFullTopicWithHttpInfo
     *
     * Update all fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FullTopic, HTTP status code, HTTP response headers (array of strings)
     */
    public function fullUpdateFullTopicWithHttpInfo(
        $guid,
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["fullUpdateFullTopic"][0]
    ) {
        $request = $this->fullUpdateFullTopicRequest(
            $guid,
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\FullTopic" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\FullTopic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\FullTopic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\FullTopic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\FullTopic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fullUpdateFullTopicAsync
     *
     * Update all fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateFullTopicAsync(
        $guid,
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["fullUpdateFullTopic"][0]
    ) {
        return $this->fullUpdateFullTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation fullUpdateFullTopicAsyncWithHttpInfo
     *
     * Update all fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateFullTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["fullUpdateFullTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\FullTopic";
        $request = $this->fullUpdateFullTopicRequest(
            $guid,
            $projects_pk,
            $full_topic_request,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fullUpdateFullTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\FullTopicRequest $full_topic_request (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fullUpdateFullTopicRequest(
        $guid,
        $projects_pk,
        $full_topic_request,
        $img_format = null,
        string $contentType = self::contentTypes["fullUpdateFullTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling fullUpdateFullTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling fullUpdateFullTopic'
            );
        }

        // verify the required parameter 'full_topic_request' is set
        if (
            $full_topic_request === null ||
            (is_array($full_topic_request) && count($full_topic_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $full_topic_request when calling fullUpdateFullTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/full-topic/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($full_topic_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $full_topic_request
                    )
                );
            } else {
                $httpBody = $full_topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PUT",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fullUpdateTopic
     *
     * Update all fields of a topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Topic
     */
    public function fullUpdateTopic(
        $guid,
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["fullUpdateTopic"][0]
    ) {
        list($response) = $this->fullUpdateTopicWithHttpInfo(
            $guid,
            $projects_pk,
            $topic_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation fullUpdateTopicWithHttpInfo
     *
     * Update all fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Topic, HTTP status code, HTTP response headers (array of strings)
     */
    public function fullUpdateTopicWithHttpInfo(
        $guid,
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["fullUpdateTopic"][0]
    ) {
        $request = $this->fullUpdateTopicRequest(
            $guid,
            $projects_pk,
            $topic_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Topic" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Topic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Topic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Topic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Topic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fullUpdateTopicAsync
     *
     * Update all fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateTopicAsync(
        $guid,
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["fullUpdateTopic"][0]
    ) {
        return $this->fullUpdateTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topic_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation fullUpdateTopicAsyncWithHttpInfo
     *
     * Update all fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["fullUpdateTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Topic";
        $request = $this->fullUpdateTopicRequest(
            $guid,
            $projects_pk,
            $topic_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fullUpdateTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\TopicRequest $topic_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fullUpdateTopicRequest(
        $guid,
        $projects_pk,
        $topic_request,
        string $contentType = self::contentTypes["fullUpdateTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling fullUpdateTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling fullUpdateTopic'
            );
        }

        // verify the required parameter 'topic_request' is set
        if (
            $topic_request === null ||
            (is_array($topic_request) && count($topic_request) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topic_request when calling fullUpdateTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/topics/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($topic_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization($topic_request)
                );
            } else {
                $httpBody = $topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PUT",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fullUpdateViewpoint
     *
     * Update all fields of a Viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Viewpoint
     */
    public function fullUpdateViewpoint(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["fullUpdateViewpoint"][0]
    ) {
        list($response) = $this->fullUpdateViewpointWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation fullUpdateViewpointWithHttpInfo
     *
     * Update all fields of a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Viewpoint, HTTP status code, HTTP response headers (array of strings)
     */
    public function fullUpdateViewpointWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["fullUpdateViewpoint"][0]
    ) {
        $request = $this->fullUpdateViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Viewpoint" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Viewpoint" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Viewpoint",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Viewpoint";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Viewpoint",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fullUpdateViewpointAsync
     *
     * Update all fields of a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateViewpointAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["fullUpdateViewpoint"][0]
    ) {
        return $this->fullUpdateViewpointAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation fullUpdateViewpointAsyncWithHttpInfo
     *
     * Update all fields of a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fullUpdateViewpointAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["fullUpdateViewpoint"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Viewpoint";
        $request = $this->fullUpdateViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $viewpoint_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fullUpdateViewpoint'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\ViewpointRequest $viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fullUpdateViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fullUpdateViewpointRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $viewpoint_request = null,
        string $contentType = self::contentTypes["fullUpdateViewpoint"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling fullUpdateViewpoint'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling fullUpdateViewpoint'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling fullUpdateViewpoint'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($viewpoint_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $viewpoint_request
                    )
                );
            } else {
                $httpBody = $viewpoint_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PUT",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBcfProject
     *
     * Retrieve a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BcfProject
     */
    public function getBcfProject(
        $id,
        string $contentType = self::contentTypes["getBcfProject"][0]
    ) {
        list($response) = $this->getBcfProjectWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getBcfProjectWithHttpInfo
     *
     * Retrieve a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BcfProject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBcfProjectWithHttpInfo(
        $id,
        string $contentType = self::contentTypes["getBcfProject"][0]
    ) {
        $request = $this->getBcfProjectRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\BcfProject" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\BcfProject" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\BcfProject",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\BcfProject";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\BcfProject",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBcfProjectAsync
     *
     * Retrieve a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBcfProjectAsync(
        $id,
        string $contentType = self::contentTypes["getBcfProject"][0]
    ) {
        return $this->getBcfProjectAsyncWithHttpInfo($id, $contentType)->then(
            function ($response) {
                return $response[0];
            }
        );
    }

    /**
     * Operation getBcfProjectAsyncWithHttpInfo
     *
     * Retrieve a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBcfProjectAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes["getBcfProject"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\BcfProject";
        $request = $this->getBcfProjectRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBcfProject'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBcfProjectRequest(
        $id,
        string $contentType = self::contentTypes["getBcfProject"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBcfProject'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBcfProjects
     *
     * Retrieve all BCF projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BcfProject[]
     */
    public function getBcfProjects(
        string $contentType = self::contentTypes["getBcfProjects"][0]
    ) {
        list($response) = $this->getBcfProjectsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getBcfProjectsWithHttpInfo
     *
     * Retrieve all BCF projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProjects'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BcfProject[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBcfProjectsWithHttpInfo(
        string $contentType = self::contentTypes["getBcfProjects"][0]
    ) {
        $request = $this->getBcfProjectsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\BcfProject[]" ===
                        "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\BcfProject[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\BcfProject[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\BcfProject[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\BcfProject[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBcfProjectsAsync
     *
     * Retrieve all BCF projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBcfProjectsAsync(
        string $contentType = self::contentTypes["getBcfProjects"][0]
    ) {
        return $this->getBcfProjectsAsyncWithHttpInfo($contentType)->then(
            function ($response) {
                return $response[0];
            }
        );
    }

    /**
     * Operation getBcfProjectsAsyncWithHttpInfo
     *
     * Retrieve all BCF projects
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBcfProjectsAsyncWithHttpInfo(
        string $contentType = self::contentTypes["getBcfProjects"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\BcfProject[]";
        $request = $this->getBcfProjectsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBcfProjects'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBcfProjects'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBcfProjectsRequest(
        string $contentType = self::contentTypes["getBcfProjects"][0]
    ) {
        $resourcePath = "/bcf/2.1/projects";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getColorings
     *
     * Retrieve all colorings of a viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getColorings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Coloring[]
     */
    public function getColorings(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getColorings"][0]
    ) {
        list($response) = $this->getColoringsWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getColoringsWithHttpInfo
     *
     * Retrieve all colorings of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getColorings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Coloring[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getColoringsWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getColorings"][0]
    ) {
        $request = $this->getColoringsRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Coloring[]" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Coloring[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Coloring[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Coloring[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Coloring[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getColoringsAsync
     *
     * Retrieve all colorings of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getColorings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getColoringsAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getColorings"][0]
    ) {
        return $this->getColoringsAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getColoringsAsyncWithHttpInfo
     *
     * Retrieve all colorings of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getColorings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getColoringsAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getColorings"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Coloring[]";
        $request = $this->getColoringsRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getColorings'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getColorings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getColoringsRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getColorings"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getColorings'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getColorings'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getColorings'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/coloring";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getComment
     *
     * Retrieve a comment
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Comment
     */
    public function getComment(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComment"][0]
    ) {
        list($response) = $this->getCommentWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getCommentWithHttpInfo
     *
     * Retrieve a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommentWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComment"][0]
    ) {
        $request = $this->getCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Comment" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Comment" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Comment",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Comment";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Comment",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCommentAsync
     *
     * Retrieve a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComment"][0]
    ) {
        return $this->getCommentAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getCommentAsyncWithHttpInfo
     *
     * Retrieve a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComment"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Comment";
        $request = $this->getCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getComment'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCommentRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComment"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getComment'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getComment'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getComment'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getComments
     *
     * Retrieve all comments
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Comment[]
     */
    public function getComments(
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComments"][0]
    ) {
        list($response) = $this->getCommentsWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getCommentsWithHttpInfo
     *
     * Retrieve all comments
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Comment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommentsWithHttpInfo(
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComments"][0]
    ) {
        $request = $this->getCommentsRequest(
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Comment[]" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Comment[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Comment[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Comment[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Comment[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCommentsAsync
     *
     * Retrieve all comments
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentsAsync(
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComments"][0]
    ) {
        return $this->getCommentsAsyncWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getCommentsAsyncWithHttpInfo
     *
     * Retrieve all comments
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentsAsyncWithHttpInfo(
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComments"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Comment[]";
        $request = $this->getCommentsRequest(
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getComments'
     *
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getComments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCommentsRequest(
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getComments"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getComments'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getComments'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDetailedExtensions
     *
     * Retrieve project detailed extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDetailedExtensions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DetailedExtensions
     */
    public function getDetailedExtensions(
        $id,
        string $contentType = self::contentTypes["getDetailedExtensions"][0]
    ) {
        list($response) = $this->getDetailedExtensionsWithHttpInfo(
            $id,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getDetailedExtensionsWithHttpInfo
     *
     * Retrieve project detailed extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDetailedExtensions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DetailedExtensions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDetailedExtensionsWithHttpInfo(
        $id,
        string $contentType = self::contentTypes["getDetailedExtensions"][0]
    ) {
        $request = $this->getDetailedExtensionsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\DetailedExtensions" ===
                        "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if (
                            "\OpenAPI\Client\Model\DetailedExtensions" !==
                            "string"
                        ) {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\DetailedExtensions",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\DetailedExtensions";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\DetailedExtensions",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDetailedExtensionsAsync
     *
     * Retrieve project detailed extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDetailedExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDetailedExtensionsAsync(
        $id,
        string $contentType = self::contentTypes["getDetailedExtensions"][0]
    ) {
        return $this->getDetailedExtensionsAsyncWithHttpInfo(
            $id,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getDetailedExtensionsAsyncWithHttpInfo
     *
     * Retrieve project detailed extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDetailedExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDetailedExtensionsAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes["getDetailedExtensions"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\DetailedExtensions";
        $request = $this->getDetailedExtensionsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDetailedExtensions'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDetailedExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDetailedExtensionsRequest(
        $id,
        string $contentType = self::contentTypes["getDetailedExtensions"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDetailedExtensions'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}/detailed-extensions";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExtensions
     *
     * Retrieve project extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtensions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Extensions
     */
    public function getExtensions(
        $id,
        string $contentType = self::contentTypes["getExtensions"][0]
    ) {
        list($response) = $this->getExtensionsWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getExtensionsWithHttpInfo
     *
     * Retrieve project extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtensions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Extensions, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExtensionsWithHttpInfo(
        $id,
        string $contentType = self::contentTypes["getExtensions"][0]
    ) {
        $request = $this->getExtensionsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Extensions" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Extensions" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Extensions",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Extensions";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Extensions",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExtensionsAsync
     *
     * Retrieve project extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExtensionsAsync(
        $id,
        string $contentType = self::contentTypes["getExtensions"][0]
    ) {
        return $this->getExtensionsAsyncWithHttpInfo($id, $contentType)->then(
            function ($response) {
                return $response[0];
            }
        );
    }

    /**
     * Operation getExtensionsAsyncWithHttpInfo
     *
     * Retrieve project extensions
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExtensionsAsyncWithHttpInfo(
        $id,
        string $contentType = self::contentTypes["getExtensions"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Extensions";
        $request = $this->getExtensionsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExtensions'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExtensions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExtensionsRequest(
        $id,
        string $contentType = self::contentTypes["getExtensions"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getExtensions'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}/extensions";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFullTopic
     *
     * Retrieve a full topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FullTopic
     */
    public function getFullTopic(
        $guid,
        $projects_pk,
        $img_format = null,
        string $contentType = self::contentTypes["getFullTopic"][0]
    ) {
        list($response) = $this->getFullTopicWithHttpInfo(
            $guid,
            $projects_pk,
            $img_format,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getFullTopicWithHttpInfo
     *
     * Retrieve a full topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FullTopic, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFullTopicWithHttpInfo(
        $guid,
        $projects_pk,
        $img_format = null,
        string $contentType = self::contentTypes["getFullTopic"][0]
    ) {
        $request = $this->getFullTopicRequest(
            $guid,
            $projects_pk,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\FullTopic" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\FullTopic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\FullTopic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\FullTopic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\FullTopic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFullTopicAsync
     *
     * Retrieve a full topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullTopicAsync(
        $guid,
        $projects_pk,
        $img_format = null,
        string $contentType = self::contentTypes["getFullTopic"][0]
    ) {
        return $this->getFullTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getFullTopicAsyncWithHttpInfo
     *
     * Retrieve a full topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $img_format = null,
        string $contentType = self::contentTypes["getFullTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\FullTopic";
        $request = $this->getFullTopicRequest(
            $guid,
            $projects_pk,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFullTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFullTopicRequest(
        $guid,
        $projects_pk,
        $img_format = null,
        string $contentType = self::contentTypes["getFullTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getFullTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getFullTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/full-topic/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFullTopics
     *
     * Retrieve all full topics
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  string $format format (optional)
     * @param  int[] $ifcs ifcs (optional)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  int[] $models models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FullTopic[]
     */
    public function getFullTopics(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $img_format = null,
        $models = null,
        string $contentType = self::contentTypes["getFullTopics"][0]
    ) {
        list($response) = $this->getFullTopicsWithHttpInfo(
            $projects_pk,
            $format,
            $ifcs,
            $img_format,
            $models,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getFullTopicsWithHttpInfo
     *
     * Retrieve all full topics
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FullTopic[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFullTopicsWithHttpInfo(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $img_format = null,
        $models = null,
        string $contentType = self::contentTypes["getFullTopics"][0]
    ) {
        $request = $this->getFullTopicsRequest(
            $projects_pk,
            $format,
            $ifcs,
            $img_format,
            $models,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\FullTopic[]" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\FullTopic[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\FullTopic[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\FullTopic[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\FullTopic[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFullTopicsAsync
     *
     * Retrieve all full topics
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullTopicsAsync(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $img_format = null,
        $models = null,
        string $contentType = self::contentTypes["getFullTopics"][0]
    ) {
        return $this->getFullTopicsAsyncWithHttpInfo(
            $projects_pk,
            $format,
            $ifcs,
            $img_format,
            $models,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getFullTopicsAsyncWithHttpInfo
     *
     * Retrieve all full topics
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullTopicsAsyncWithHttpInfo(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $img_format = null,
        $models = null,
        string $contentType = self::contentTypes["getFullTopics"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\FullTopic[]";
        $request = $this->getFullTopicsRequest(
            $projects_pk,
            $format,
            $ifcs,
            $img_format,
            $models,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFullTopics'
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFullTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFullTopicsRequest(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $img_format = null,
        $models = null,
        string $contentType = self::contentTypes["getFullTopics"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getFullTopics'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/full-topic";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $format,
                "format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );
        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $ifcs,
                "ifcs", // param base name
                "array", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );
        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );
        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $models,
                "models", // param base name
                "array", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSelections
     *
     * Retrieve all selections of a viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSelections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Component[]
     */
    public function getSelections(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSelections"][0]
    ) {
        list($response) = $this->getSelectionsWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getSelectionsWithHttpInfo
     *
     * Retrieve all selections of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSelections'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Component[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSelectionsWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSelections"][0]
    ) {
        $request = $this->getSelectionsRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Component[]" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Component[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Component[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Component[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Component[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSelectionsAsync
     *
     * Retrieve all selections of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSelections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSelectionsAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSelections"][0]
    ) {
        return $this->getSelectionsAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getSelectionsAsyncWithHttpInfo
     *
     * Retrieve all selections of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSelections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSelectionsAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSelections"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Component[]";
        $request = $this->getSelectionsRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSelections'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSelections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSelectionsRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSelections"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getSelections'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getSelections'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getSelections'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/selection";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSnapshot
     *
     * Retrieve the viewpoint&#39; snapshot
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSnapshot'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getSnapshot(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSnapshot"][0]
    ) {
        list($response) = $this->getSnapshotWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getSnapshotWithHttpInfo
     *
     * Retrieve the viewpoint&#39; snapshot
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSnapshot'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSnapshotWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSnapshot"][0]
    ) {
        $request = $this->getSnapshotRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\SplFileObject" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\SplFileObject" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\SplFileObject",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\SplFileObject";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\SplFileObject",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSnapshotAsync
     *
     * Retrieve the viewpoint&#39; snapshot
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSnapshot'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSnapshot"][0]
    ) {
        return $this->getSnapshotAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getSnapshotAsyncWithHttpInfo
     *
     * Retrieve the viewpoint&#39; snapshot
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSnapshot'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSnapshot"][0]
    ) {
        $returnType = "\SplFileObject";
        $request = $this->getSnapshotRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSnapshot'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSnapshot'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSnapshotRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getSnapshot"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getSnapshot'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getSnapshot'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getSnapshot'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/snapshot";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopic
     *
     * Retrieve a topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Topic
     */
    public function getTopic(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["getTopic"][0]
    ) {
        list($response) = $this->getTopicWithHttpInfo(
            $guid,
            $projects_pk,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getTopicWithHttpInfo
     *
     * Retrieve a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Topic, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicWithHttpInfo(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["getTopic"][0]
    ) {
        $request = $this->getTopicRequest($guid, $projects_pk, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Topic" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Topic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Topic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Topic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Topic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicAsync
     *
     * Retrieve a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicAsync(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["getTopic"][0]
    ) {
        return $this->getTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getTopicAsyncWithHttpInfo
     *
     * Retrieve a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["getTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Topic";
        $request = $this->getTopicRequest($guid, $projects_pk, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTopicRequest(
        $guid,
        $projects_pk,
        string $contentType = self::contentTypes["getTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/topics/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopicViewpoints
     *
     * Retrieve all viewpoints attached to the topic
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopicViewpoints'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Viewpoint[]
     */
    public function getTopicViewpoints(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getTopicViewpoints"][0]
    ) {
        list($response) = $this->getTopicViewpointsWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getTopicViewpointsWithHttpInfo
     *
     * Retrieve all viewpoints attached to the topic
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopicViewpoints'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Viewpoint[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicViewpointsWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getTopicViewpoints"][0]
    ) {
        $request = $this->getTopicViewpointsRequest(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Viewpoint[]" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Viewpoint[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Viewpoint[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Viewpoint[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Viewpoint[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicViewpointsAsync
     *
     * Retrieve all viewpoints attached to the topic
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopicViewpoints'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicViewpointsAsync(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getTopicViewpoints"][0]
    ) {
        return $this->getTopicViewpointsAsyncWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getTopicViewpointsAsyncWithHttpInfo
     *
     * Retrieve all viewpoints attached to the topic
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopicViewpoints'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicViewpointsAsyncWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getTopicViewpoints"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Viewpoint[]";
        $request = $this->getTopicViewpointsRequest(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopicViewpoints'
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopicViewpoints'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTopicViewpointsRequest(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getTopicViewpoints"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getTopicViewpoints'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getTopicViewpoints'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/topic-viewpoints";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopics
     *
     * Retrieve all topics
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  string $format format (optional)
     * @param  int[] $ifcs ifcs (optional)
     * @param  int[] $models models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Topic[]
     */
    public function getTopics(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $models = null,
        string $contentType = self::contentTypes["getTopics"][0]
    ) {
        list($response) = $this->getTopicsWithHttpInfo(
            $projects_pk,
            $format,
            $ifcs,
            $models,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getTopicsWithHttpInfo
     *
     * Retrieve all topics
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Topic[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicsWithHttpInfo(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $models = null,
        string $contentType = self::contentTypes["getTopics"][0]
    ) {
        $request = $this->getTopicsRequest(
            $projects_pk,
            $format,
            $ifcs,
            $models,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Topic[]" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Topic[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Topic[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Topic[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Topic[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicsAsync
     *
     * Retrieve all topics
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsync(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $models = null,
        string $contentType = self::contentTypes["getTopics"][0]
    ) {
        return $this->getTopicsAsyncWithHttpInfo(
            $projects_pk,
            $format,
            $ifcs,
            $models,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getTopicsAsyncWithHttpInfo
     *
     * Retrieve all topics
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsyncWithHttpInfo(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $models = null,
        string $contentType = self::contentTypes["getTopics"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Topic[]";
        $request = $this->getTopicsRequest(
            $projects_pk,
            $format,
            $ifcs,
            $models,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopics'
     *
     * @param  int $projects_pk (required)
     * @param  string $format (optional)
     * @param  int[] $ifcs (optional)
     * @param  int[] $models (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTopics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTopicsRequest(
        $projects_pk,
        $format = null,
        $ifcs = null,
        $models = null,
        string $contentType = self::contentTypes["getTopics"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getTopics'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/topics";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $format,
                "format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );
        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $ifcs,
                "ifcs", // param base name
                "array", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );
        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $models,
                "models", // param base name
                "array", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUser
     *
     * Get current user info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SelfBcfUser
     */
    public function getUser(
        string $contentType = self::contentTypes["getUser"][0]
    ) {
        list($response) = $this->getUserWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getUserWithHttpInfo
     *
     * Get current user info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SelfBcfUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo(
        string $contentType = self::contentTypes["getUser"][0]
    ) {
        $request = $this->getUserRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\SelfBcfUser" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\SelfBcfUser" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\SelfBcfUser",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\SelfBcfUser";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\SelfBcfUser",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAsync
     *
     * Get current user info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsync(
        string $contentType = self::contentTypes["getUser"][0]
    ) {
        return $this->getUserAsyncWithHttpInfo($contentType)->then(function (
            $response
        ) {
            return $response[0];
        });
    }

    /**
     * Operation getUserAsyncWithHttpInfo
     *
     * Get current user info
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUserAsyncWithHttpInfo(
        string $contentType = self::contentTypes["getUser"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\SelfBcfUser";
        $request = $this->getUserRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUser'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserRequest(
        string $contentType = self::contentTypes["getUser"][0]
    ) {
        $resourcePath = "/bcf/2.1/current-user";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getViewpoint
     *
     * Retrieve a Viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Viewpoint
     */
    public function getViewpoint(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoint"][0]
    ) {
        list($response) = $this->getViewpointWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getViewpointWithHttpInfo
     *
     * Retrieve a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Viewpoint, HTTP status code, HTTP response headers (array of strings)
     */
    public function getViewpointWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoint"][0]
    ) {
        $request = $this->getViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Viewpoint" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Viewpoint" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Viewpoint",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Viewpoint";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Viewpoint",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getViewpointAsync
     *
     * Retrieve a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getViewpointAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoint"][0]
    ) {
        return $this->getViewpointAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getViewpointAsyncWithHttpInfo
     *
     * Retrieve a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getViewpointAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoint"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Viewpoint";
        $request = $this->getViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getViewpoint'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getViewpointRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoint"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getViewpoint'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getViewpoint'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getViewpoint'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getViewpoints
     *
     * Retrieve all Viewpoints of a topic
     *
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoints'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Viewpoint[]
     */
    public function getViewpoints(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoints"][0]
    ) {
        list($response) = $this->getViewpointsWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getViewpointsWithHttpInfo
     *
     * Retrieve all Viewpoints of a topic
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoints'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Viewpoint[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getViewpointsWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoints"][0]
    ) {
        $request = $this->getViewpointsRequest(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Viewpoint[]" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Viewpoint[]" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Viewpoint[]",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Viewpoint[]";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Viewpoint[]",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getViewpointsAsync
     *
     * Retrieve all Viewpoints of a topic
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoints'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getViewpointsAsync(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoints"][0]
    ) {
        return $this->getViewpointsAsyncWithHttpInfo(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getViewpointsAsyncWithHttpInfo
     *
     * Retrieve all Viewpoints of a topic
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoints'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getViewpointsAsyncWithHttpInfo(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoints"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Viewpoint[]";
        $request = $this->getViewpointsRequest(
            $projects_pk,
            $topics_guid,
            $img_format,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getViewpoints'
     *
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getViewpoints'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getViewpointsRequest(
        $projects_pk,
        $topics_guid,
        $img_format = null,
        string $contentType = self::contentTypes["getViewpoints"][0]
    ) {
        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getViewpoints'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getViewpoints'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVisibilities
     *
     * Retrieve all visibilities of a viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVisibilities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Visibility
     */
    public function getVisibilities(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getVisibilities"][0]
    ) {
        list($response) = $this->getVisibilitiesWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );
        return $response;
    }

    /**
     * Operation getVisibilitiesWithHttpInfo
     *
     * Retrieve all visibilities of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVisibilities'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Visibility, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVisibilitiesWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getVisibilities"][0]
    ) {
        $request = $this->getVisibilitiesRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Visibility" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Visibility" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Visibility",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Visibility";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Visibility",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVisibilitiesAsync
     *
     * Retrieve all visibilities of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVisibilities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVisibilitiesAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getVisibilities"][0]
    ) {
        return $this->getVisibilitiesAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation getVisibilitiesAsyncWithHttpInfo
     *
     * Retrieve all visibilities of a viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVisibilities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVisibilitiesAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getVisibilities"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Visibility";
        $request = $this->getVisibilitiesRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVisibilities'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getVisibilities'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getVisibilitiesRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        string $contentType = self::contentTypes["getVisibilities"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling getVisibilities'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling getVisibilities'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling getVisibilities'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}/visibility";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "GET",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importBcf
     *
     * Import bcf-xml format into this project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $name Name of the project (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importBcf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function importBcf(
        $id,
        $name,
        string $contentType = self::contentTypes["importBcf"][0]
    ) {
        $this->importBcfWithHttpInfo($id, $name, $contentType);
    }

    /**
     * Operation importBcfWithHttpInfo
     *
     * Import bcf-xml format into this project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $name Name of the project (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importBcf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function importBcfWithHttpInfo(
        $id,
        $name,
        string $contentType = self::contentTypes["importBcf"][0]
    ) {
        $request = $this->importBcfRequest($id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation importBcfAsync
     *
     * Import bcf-xml format into this project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $name Name of the project (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importBcf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importBcfAsync(
        $id,
        $name,
        string $contentType = self::contentTypes["importBcf"][0]
    ) {
        return $this->importBcfAsyncWithHttpInfo(
            $id,
            $name,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation importBcfAsyncWithHttpInfo
     *
     * Import bcf-xml format into this project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $name Name of the project (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importBcf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importBcfAsyncWithHttpInfo(
        $id,
        $name,
        string $contentType = self::contentTypes["importBcf"][0]
    ) {
        $returnType = "";
        $request = $this->importBcfRequest($id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [
                        null,
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importBcf'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  string $name Name of the project (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importBcf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importBcfRequest(
        $id,
        $name,
        string $contentType = self::contentTypes["importBcf"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling importBcf'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling importBcf'
            );
        }
        if (strlen($name) > 256) {
            throw new \InvalidArgumentException(
                'invalid length for "$name" when calling BcfApi.importBcf, must be smaller than or equal to 256.'
            );
        }
        if (strlen($name) < 1) {
            throw new \InvalidArgumentException(
                'invalid length for "$name" when calling BcfApi.importBcf, must be bigger than or equal to 1.'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}/import";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams["name"] = ObjectSerializer::toFormValue($name);
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "POST",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBcfProject
     *
     * Update some fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\PatchedBcfProjectRequest $patched_bcf_project_request patched_bcf_project_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBcfProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BcfProject
     */
    public function updateBcfProject(
        $id,
        $patched_bcf_project_request = null,
        string $contentType = self::contentTypes["updateBcfProject"][0]
    ) {
        list($response) = $this->updateBcfProjectWithHttpInfo(
            $id,
            $patched_bcf_project_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateBcfProjectWithHttpInfo
     *
     * Update some fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\PatchedBcfProjectRequest $patched_bcf_project_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBcfProject'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BcfProject, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBcfProjectWithHttpInfo(
        $id,
        $patched_bcf_project_request = null,
        string $contentType = self::contentTypes["updateBcfProject"][0]
    ) {
        $request = $this->updateBcfProjectRequest(
            $id,
            $patched_bcf_project_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\BcfProject" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\BcfProject" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\BcfProject",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\BcfProject";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\BcfProject",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBcfProjectAsync
     *
     * Update some fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\PatchedBcfProjectRequest $patched_bcf_project_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBcfProjectAsync(
        $id,
        $patched_bcf_project_request = null,
        string $contentType = self::contentTypes["updateBcfProject"][0]
    ) {
        return $this->updateBcfProjectAsyncWithHttpInfo(
            $id,
            $patched_bcf_project_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateBcfProjectAsyncWithHttpInfo
     *
     * Update some fields of a BCF project
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\PatchedBcfProjectRequest $patched_bcf_project_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBcfProjectAsyncWithHttpInfo(
        $id,
        $patched_bcf_project_request = null,
        string $contentType = self::contentTypes["updateBcfProject"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\BcfProject";
        $request = $this->updateBcfProjectRequest(
            $id,
            $patched_bcf_project_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBcfProject'
     *
     * @param  int $id A unique integer value identifying this project. (required)
     * @param  \OpenAPI\Client\Model\PatchedBcfProjectRequest $patched_bcf_project_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBcfProject'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateBcfProjectRequest(
        $id,
        $patched_bcf_project_request = null,
        string $contentType = self::contentTypes["updateBcfProject"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateBcfProject'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_bcf_project_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_bcf_project_request
                    )
                );
            } else {
                $httpBody = $patched_bcf_project_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateComment
     *
     * Update some fields of a comment
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  \OpenAPI\Client\Model\PatchedCommentRequest $patched_comment_request patched_comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Comment
     */
    public function updateComment(
        $guid,
        $projects_pk,
        $topics_guid,
        $patched_comment_request = null,
        string $contentType = self::contentTypes["updateComment"][0]
    ) {
        list($response) = $this->updateCommentWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $patched_comment_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateCommentWithHttpInfo
     *
     * Update some fields of a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\PatchedCommentRequest $patched_comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCommentWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $patched_comment_request = null,
        string $contentType = self::contentTypes["updateComment"][0]
    ) {
        $request = $this->updateCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $patched_comment_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Comment" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Comment" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Comment",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Comment";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Comment",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCommentAsync
     *
     * Update some fields of a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\PatchedCommentRequest $patched_comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCommentAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        $patched_comment_request = null,
        string $contentType = self::contentTypes["updateComment"][0]
    ) {
        return $this->updateCommentAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $patched_comment_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateCommentAsyncWithHttpInfo
     *
     * Update some fields of a comment
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\PatchedCommentRequest $patched_comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCommentAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $patched_comment_request = null,
        string $contentType = self::contentTypes["updateComment"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Comment";
        $request = $this->updateCommentRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $patched_comment_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateComment'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk A unique integer value identifying this project. (required)
     * @param  string $topics_guid (required)
     * @param  \OpenAPI\Client\Model\PatchedCommentRequest $patched_comment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCommentRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        $patched_comment_request = null,
        string $contentType = self::contentTypes["updateComment"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling updateComment'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateComment'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling updateComment'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/comments/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_comment_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_comment_request
                    )
                );
            } else {
                $httpBody = $patched_comment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateExtensionLabel
     *
     * Update a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedLabelRequest $patched_label_request patched_label_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionLabel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Label
     */
    public function updateExtensionLabel(
        $id,
        $projects_pk,
        $patched_label_request = null,
        string $contentType = self::contentTypes["updateExtensionLabel"][0]
    ) {
        list($response) = $this->updateExtensionLabelWithHttpInfo(
            $id,
            $projects_pk,
            $patched_label_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateExtensionLabelWithHttpInfo
     *
     * Update a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedLabelRequest $patched_label_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionLabel'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Label, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExtensionLabelWithHttpInfo(
        $id,
        $projects_pk,
        $patched_label_request = null,
        string $contentType = self::contentTypes["updateExtensionLabel"][0]
    ) {
        $request = $this->updateExtensionLabelRequest(
            $id,
            $projects_pk,
            $patched_label_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Label" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Label" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Label",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Label";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Label",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExtensionLabelAsync
     *
     * Update a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedLabelRequest $patched_label_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionLabelAsync(
        $id,
        $projects_pk,
        $patched_label_request = null,
        string $contentType = self::contentTypes["updateExtensionLabel"][0]
    ) {
        return $this->updateExtensionLabelAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $patched_label_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateExtensionLabelAsyncWithHttpInfo
     *
     * Update a Label
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedLabelRequest $patched_label_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionLabelAsyncWithHttpInfo(
        $id,
        $projects_pk,
        $patched_label_request = null,
        string $contentType = self::contentTypes["updateExtensionLabel"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Label";
        $request = $this->updateExtensionLabelRequest(
            $id,
            $projects_pk,
            $patched_label_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExtensionLabel'
     *
     * @param  int $id A unique integer value identifying this label. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedLabelRequest $patched_label_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionLabel'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateExtensionLabelRequest(
        $id,
        $projects_pk,
        $patched_label_request = null,
        string $contentType = self::contentTypes["updateExtensionLabel"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateExtensionLabel'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateExtensionLabel'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/label/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_label_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_label_request
                    )
                );
            } else {
                $httpBody = $patched_label_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateExtensionPriority
     *
     * Update a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedPriorityRequest $patched_priority_request patched_priority_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionPriority'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Priority
     */
    public function updateExtensionPriority(
        $id,
        $projects_pk,
        $patched_priority_request = null,
        string $contentType = self::contentTypes["updateExtensionPriority"][0]
    ) {
        list($response) = $this->updateExtensionPriorityWithHttpInfo(
            $id,
            $projects_pk,
            $patched_priority_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateExtensionPriorityWithHttpInfo
     *
     * Update a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedPriorityRequest $patched_priority_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionPriority'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Priority, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExtensionPriorityWithHttpInfo(
        $id,
        $projects_pk,
        $patched_priority_request = null,
        string $contentType = self::contentTypes["updateExtensionPriority"][0]
    ) {
        $request = $this->updateExtensionPriorityRequest(
            $id,
            $projects_pk,
            $patched_priority_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Priority" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Priority" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Priority",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Priority";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Priority",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExtensionPriorityAsync
     *
     * Update a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedPriorityRequest $patched_priority_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionPriorityAsync(
        $id,
        $projects_pk,
        $patched_priority_request = null,
        string $contentType = self::contentTypes["updateExtensionPriority"][0]
    ) {
        return $this->updateExtensionPriorityAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $patched_priority_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateExtensionPriorityAsyncWithHttpInfo
     *
     * Update a Priority
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedPriorityRequest $patched_priority_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionPriorityAsyncWithHttpInfo(
        $id,
        $projects_pk,
        $patched_priority_request = null,
        string $contentType = self::contentTypes["updateExtensionPriority"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Priority";
        $request = $this->updateExtensionPriorityRequest(
            $id,
            $projects_pk,
            $patched_priority_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExtensionPriority'
     *
     * @param  int $id A unique integer value identifying this priority. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedPriorityRequest $patched_priority_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionPriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateExtensionPriorityRequest(
        $id,
        $projects_pk,
        $patched_priority_request = null,
        string $contentType = self::contentTypes["updateExtensionPriority"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateExtensionPriority'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateExtensionPriority'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/extension/priority/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_priority_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_priority_request
                    )
                );
            } else {
                $httpBody = $patched_priority_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateExtensionStage
     *
     * Update a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedStageRequest $patched_stage_request patched_stage_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Stage
     */
    public function updateExtensionStage(
        $id,
        $projects_pk,
        $patched_stage_request = null,
        string $contentType = self::contentTypes["updateExtensionStage"][0]
    ) {
        list($response) = $this->updateExtensionStageWithHttpInfo(
            $id,
            $projects_pk,
            $patched_stage_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateExtensionStageWithHttpInfo
     *
     * Update a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedStageRequest $patched_stage_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStage'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Stage, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExtensionStageWithHttpInfo(
        $id,
        $projects_pk,
        $patched_stage_request = null,
        string $contentType = self::contentTypes["updateExtensionStage"][0]
    ) {
        $request = $this->updateExtensionStageRequest(
            $id,
            $projects_pk,
            $patched_stage_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Stage" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Stage" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Stage",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Stage";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Stage",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExtensionStageAsync
     *
     * Update a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedStageRequest $patched_stage_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionStageAsync(
        $id,
        $projects_pk,
        $patched_stage_request = null,
        string $contentType = self::contentTypes["updateExtensionStage"][0]
    ) {
        return $this->updateExtensionStageAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $patched_stage_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateExtensionStageAsyncWithHttpInfo
     *
     * Update a Stage
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedStageRequest $patched_stage_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionStageAsyncWithHttpInfo(
        $id,
        $projects_pk,
        $patched_stage_request = null,
        string $contentType = self::contentTypes["updateExtensionStage"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Stage";
        $request = $this->updateExtensionStageRequest(
            $id,
            $projects_pk,
            $patched_stage_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExtensionStage'
     *
     * @param  int $id A unique integer value identifying this stage. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedStageRequest $patched_stage_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateExtensionStageRequest(
        $id,
        $projects_pk,
        $patched_stage_request = null,
        string $contentType = self::contentTypes["updateExtensionStage"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateExtensionStage'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateExtensionStage'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/stage/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_stage_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_stage_request
                    )
                );
            } else {
                $httpBody = $patched_stage_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateExtensionStatus
     *
     * Update a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicStatusRequest $patched_topic_status_request patched_topic_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TopicStatus
     */
    public function updateExtensionStatus(
        $id,
        $projects_pk,
        $patched_topic_status_request = null,
        string $contentType = self::contentTypes["updateExtensionStatus"][0]
    ) {
        list($response) = $this->updateExtensionStatusWithHttpInfo(
            $id,
            $projects_pk,
            $patched_topic_status_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateExtensionStatusWithHttpInfo
     *
     * Update a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicStatusRequest $patched_topic_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TopicStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExtensionStatusWithHttpInfo(
        $id,
        $projects_pk,
        $patched_topic_status_request = null,
        string $contentType = self::contentTypes["updateExtensionStatus"][0]
    ) {
        $request = $this->updateExtensionStatusRequest(
            $id,
            $projects_pk,
            $patched_topic_status_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\TopicStatus" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\TopicStatus" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\TopicStatus",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\TopicStatus";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\TopicStatus",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExtensionStatusAsync
     *
     * Update a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicStatusRequest $patched_topic_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionStatusAsync(
        $id,
        $projects_pk,
        $patched_topic_status_request = null,
        string $contentType = self::contentTypes["updateExtensionStatus"][0]
    ) {
        return $this->updateExtensionStatusAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $patched_topic_status_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateExtensionStatusAsyncWithHttpInfo
     *
     * Update a TopicStatus
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicStatusRequest $patched_topic_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionStatusAsyncWithHttpInfo(
        $id,
        $projects_pk,
        $patched_topic_status_request = null,
        string $contentType = self::contentTypes["updateExtensionStatus"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\TopicStatus";
        $request = $this->updateExtensionStatusRequest(
            $id,
            $projects_pk,
            $patched_topic_status_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExtensionStatus'
     *
     * @param  int $id A unique integer value identifying this topic status. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicStatusRequest $patched_topic_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateExtensionStatusRequest(
        $id,
        $projects_pk,
        $patched_topic_status_request = null,
        string $contentType = self::contentTypes["updateExtensionStatus"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateExtensionStatus'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateExtensionStatus'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/status/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_topic_status_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_topic_status_request
                    )
                );
            } else {
                $httpBody = $patched_topic_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateExtensionType
     *
     * Update a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicTypeRequest $patched_topic_type_request patched_topic_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TopicType
     */
    public function updateExtensionType(
        $id,
        $projects_pk,
        $patched_topic_type_request = null,
        string $contentType = self::contentTypes["updateExtensionType"][0]
    ) {
        list($response) = $this->updateExtensionTypeWithHttpInfo(
            $id,
            $projects_pk,
            $patched_topic_type_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateExtensionTypeWithHttpInfo
     *
     * Update a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicTypeRequest $patched_topic_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TopicType, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExtensionTypeWithHttpInfo(
        $id,
        $projects_pk,
        $patched_topic_type_request = null,
        string $contentType = self::contentTypes["updateExtensionType"][0]
    ) {
        $request = $this->updateExtensionTypeRequest(
            $id,
            $projects_pk,
            $patched_topic_type_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\TopicType" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\TopicType" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\TopicType",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\TopicType";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\TopicType",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateExtensionTypeAsync
     *
     * Update a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicTypeRequest $patched_topic_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionTypeAsync(
        $id,
        $projects_pk,
        $patched_topic_type_request = null,
        string $contentType = self::contentTypes["updateExtensionType"][0]
    ) {
        return $this->updateExtensionTypeAsyncWithHttpInfo(
            $id,
            $projects_pk,
            $patched_topic_type_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateExtensionTypeAsyncWithHttpInfo
     *
     * Update a TopicType
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicTypeRequest $patched_topic_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExtensionTypeAsyncWithHttpInfo(
        $id,
        $projects_pk,
        $patched_topic_type_request = null,
        string $contentType = self::contentTypes["updateExtensionType"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\TopicType";
        $request = $this->updateExtensionTypeRequest(
            $id,
            $projects_pk,
            $patched_topic_type_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExtensionType'
     *
     * @param  int $id A unique integer value identifying this topic type. (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicTypeRequest $patched_topic_type_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateExtensionType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateExtensionTypeRequest(
        $id,
        $projects_pk,
        $patched_topic_type_request = null,
        string $contentType = self::contentTypes["updateExtensionType"][0]
    ) {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateExtensionType'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateExtensionType'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/extension/type/{id}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_topic_type_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_topic_type_request
                    )
                );
            } else {
                $httpBody = $patched_topic_type_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFullTopic
     *
     * Update some fields of a topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedFullTopicRequest $patched_full_topic_request patched_full_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FullTopic
     */
    public function updateFullTopic(
        $guid,
        $projects_pk,
        $img_format = null,
        $patched_full_topic_request = null,
        string $contentType = self::contentTypes["updateFullTopic"][0]
    ) {
        list($response) = $this->updateFullTopicWithHttpInfo(
            $guid,
            $projects_pk,
            $img_format,
            $patched_full_topic_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateFullTopicWithHttpInfo
     *
     * Update some fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedFullTopicRequest $patched_full_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFullTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FullTopic, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFullTopicWithHttpInfo(
        $guid,
        $projects_pk,
        $img_format = null,
        $patched_full_topic_request = null,
        string $contentType = self::contentTypes["updateFullTopic"][0]
    ) {
        $request = $this->updateFullTopicRequest(
            $guid,
            $projects_pk,
            $img_format,
            $patched_full_topic_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\FullTopic" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\FullTopic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\FullTopic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\FullTopic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\FullTopic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateFullTopicAsync
     *
     * Update some fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedFullTopicRequest $patched_full_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFullTopicAsync(
        $guid,
        $projects_pk,
        $img_format = null,
        $patched_full_topic_request = null,
        string $contentType = self::contentTypes["updateFullTopic"][0]
    ) {
        return $this->updateFullTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $img_format,
            $patched_full_topic_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateFullTopicAsyncWithHttpInfo
     *
     * Update some fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedFullTopicRequest $patched_full_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFullTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $img_format = null,
        $patched_full_topic_request = null,
        string $contentType = self::contentTypes["updateFullTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\FullTopic";
        $request = $this->updateFullTopicRequest(
            $guid,
            $projects_pk,
            $img_format,
            $patched_full_topic_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFullTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedFullTopicRequest $patched_full_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFullTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFullTopicRequest(
        $guid,
        $projects_pk,
        $img_format = null,
        $patched_full_topic_request = null,
        string $contentType = self::contentTypes["updateFullTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling updateFullTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateFullTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/full-topic/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_full_topic_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_full_topic_request
                    )
                );
            } else {
                $httpBody = $patched_full_topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTopic
     *
     * Update some fields of a topic
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicRequest $patched_topic_request patched_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Topic
     */
    public function updateTopic(
        $guid,
        $projects_pk,
        $patched_topic_request = null,
        string $contentType = self::contentTypes["updateTopic"][0]
    ) {
        list($response) = $this->updateTopicWithHttpInfo(
            $guid,
            $projects_pk,
            $patched_topic_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateTopicWithHttpInfo
     *
     * Update some fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicRequest $patched_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTopic'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Topic, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTopicWithHttpInfo(
        $guid,
        $projects_pk,
        $patched_topic_request = null,
        string $contentType = self::contentTypes["updateTopic"][0]
    ) {
        $request = $this->updateTopicRequest(
            $guid,
            $projects_pk,
            $patched_topic_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if ("\OpenAPI\Client\Model\Topic" === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Topic" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Topic",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Topic";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Topic",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTopicAsync
     *
     * Update some fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicRequest $patched_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicAsync(
        $guid,
        $projects_pk,
        $patched_topic_request = null,
        string $contentType = self::contentTypes["updateTopic"][0]
    ) {
        return $this->updateTopicAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $patched_topic_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateTopicAsyncWithHttpInfo
     *
     * Update some fields of a topic
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicRequest $patched_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTopicAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $patched_topic_request = null,
        string $contentType = self::contentTypes["updateTopic"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Topic";
        $request = $this->updateTopicRequest(
            $guid,
            $projects_pk,
            $patched_topic_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTopic'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  \OpenAPI\Client\Model\PatchedTopicRequest $patched_topic_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTopic'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTopicRequest(
        $guid,
        $projects_pk,
        $patched_topic_request = null,
        string $contentType = self::contentTypes["updateTopic"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling updateTopic'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateTopic'
            );
        }

        $resourcePath = "/bcf/2.1/projects/{projects_pk}/topics/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_topic_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_topic_request
                    )
                );
            } else {
                $httpBody = $patched_topic_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateViewpoint
     *
     * Update some fields of a Viewpoint
     *
     * @param  string $guid guid (required)
     * @param  int $projects_pk projects_pk (required)
     * @param  string $topics_guid topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedViewpointRequest $patched_viewpoint_request patched_viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Viewpoint
     */
    public function updateViewpoint(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $patched_viewpoint_request = null,
        string $contentType = self::contentTypes["updateViewpoint"][0]
    ) {
        list($response) = $this->updateViewpointWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $patched_viewpoint_request,
            $contentType
        );
        return $response;
    }

    /**
     * Operation updateViewpointWithHttpInfo
     *
     * Update some fields of a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedViewpointRequest $patched_viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateViewpoint'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Viewpoint, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateViewpointWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $patched_viewpoint_request = null,
        string $contentType = self::contentTypes["updateViewpoint"][0]
    ) {
        $request = $this->updateViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $patched_viewpoint_request,
            $contentType
        );

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()
                        ? (string) $e->getResponse()->getBody()
                        : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        "[%d] Error connecting to the API (%s)",
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch ($statusCode) {
                case 200:
                    if (
                        "\OpenAPI\Client\Model\Viewpoint" === "\SplFileObject"
                    ) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ("\OpenAPI\Client\Model\Viewpoint" !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            "\OpenAPI\Client\Model\Viewpoint",
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = "\OpenAPI\Client\Model\Viewpoint";
            if ($returnType === "\SplFileObject") {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== "string") {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        "\OpenAPI\Client\Model\Viewpoint",
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateViewpointAsync
     *
     * Update some fields of a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedViewpointRequest $patched_viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateViewpointAsync(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $patched_viewpoint_request = null,
        string $contentType = self::contentTypes["updateViewpoint"][0]
    ) {
        return $this->updateViewpointAsyncWithHttpInfo(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $patched_viewpoint_request,
            $contentType
        )->then(function ($response) {
            return $response[0];
        });
    }

    /**
     * Operation updateViewpointAsyncWithHttpInfo
     *
     * Update some fields of a Viewpoint
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedViewpointRequest $patched_viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateViewpointAsyncWithHttpInfo(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $patched_viewpoint_request = null,
        string $contentType = self::contentTypes["updateViewpoint"][0]
    ) {
        $returnType = "\OpenAPI\Client\Model\Viewpoint";
        $request = $this->updateViewpointRequest(
            $guid,
            $projects_pk,
            $topics_guid,
            $img_format,
            $patched_viewpoint_request,
            $contentType
        );

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === "\SplFileObject") {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== "string") {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize(
                            $content,
                            $returnType,
                            []
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            "[%d] Error connecting to the API (%s)",
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateViewpoint'
     *
     * @param  string $guid (required)
     * @param  int $projects_pk (required)
     * @param  string $topics_guid (required)
     * @param  string $img_format All snapshot_data will be returned as url instead of base64 (optional)
     * @param  \OpenAPI\Client\Model\PatchedViewpointRequest $patched_viewpoint_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateViewpoint'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateViewpointRequest(
        $guid,
        $projects_pk,
        $topics_guid,
        $img_format = null,
        $patched_viewpoint_request = null,
        string $contentType = self::contentTypes["updateViewpoint"][0]
    ) {
        // verify the required parameter 'guid' is set
        if ($guid === null || (is_array($guid) && count($guid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $guid when calling updateViewpoint'
            );
        }

        // verify the required parameter 'projects_pk' is set
        if (
            $projects_pk === null ||
            (is_array($projects_pk) && count($projects_pk) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $projects_pk when calling updateViewpoint'
            );
        }

        // verify the required parameter 'topics_guid' is set
        if (
            $topics_guid === null ||
            (is_array($topics_guid) && count($topics_guid) === 0)
        ) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topics_guid when calling updateViewpoint'
            );
        }

        $resourcePath =
            "/bcf/2.1/projects/{projects_pk}/topics/{topics_guid}/viewpoints/{guid}";
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = "";
        $multipart = false;

        // query params
        $queryParams = array_merge(
            $queryParams,
            ObjectSerializer::toQueryValue(
                $img_format,
                "img_format", // param base name
                "string", // openApiType
                "form", // style
                true, // explode
                false // required
            ) ?? []
        );

        // path params
        if ($guid !== null) {
            $resourcePath = str_replace(
                "{" . "guid" . "}",
                ObjectSerializer::toPathValue($guid),
                $resourcePath
            );
        }
        // path params
        if ($projects_pk !== null) {
            $resourcePath = str_replace(
                "{" . "projects_pk" . "}",
                ObjectSerializer::toPathValue($projects_pk),
                $resourcePath
            );
        }
        // path params
        if ($topics_guid !== null) {
            $resourcePath = str_replace(
                "{" . "topics_guid" . "}",
                ObjectSerializer::toPathValue($topics_guid),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ["application/json"],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_viewpoint_request)) {
            if (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(
                    ObjectSerializer::sanitizeForSerialization(
                        $patched_viewpoint_request
                    )
                );
            } else {
                $httpBody = $patched_viewpoint_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue)
                        ? $formParamValue
                        : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            "name" => $formParamName,
                            "contents" => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (
                stripos($headers["Content-Type"], "application/json") !== false
            ) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers["Authorization"] =
                "Bearer " . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix("Authorization");
        if ($apiKey !== null) {
            $headers["Authorization"] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders["User-Agent"] = $this->config->getUserAgent();
        }

        $headers = array_merge($defaultHeaders, $headerParams, $headers);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            "PATCH",
            $operationHost . $resourcePath . ($query ? "?{$query}" : ""),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen(
                $this->config->getDebugFile(),
                "a"
            );
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException(
                    "Failed to open the debug file: " .
                        $this->config->getDebugFile()
                );
            }
        }

        return $options;
    }
}
